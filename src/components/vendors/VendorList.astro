---
import { supabase } from '../../lib/supabaseClient';
import { getCached, setCached } from '../../lib/cache';
import VendorCard from '../VendorCard.astro';
import Pagination from '../Pagination.astro';
import { normalizeTech } from '../../lib/normalizeTech';
import { getIndustries } from '../../lib/getIndustries';
import { normalizeVendors } from '../../lib/vendors/vendorUtils';

interface VendorListProps {
  lang: "en" | "de";
  pageTitle: string;
  description?: string;
}

import type { Category } from '../../types/category';

const { lang, pageTitle, description } = Astro.props;

// Parse URL parameters (decode URL-encoded values safely)
function safeDecode(param: string | null): string {
  if (!param) return '';
  try {
    return decodeURIComponent(param).trim();
  } catch {
    return param.trim();
  }
}

const searchQuery = safeDecode(Astro.url.searchParams.get('q'));
const countryFilter = safeDecode(Astro.url.searchParams.get('country'));
const activeCategory = safeDecode(Astro.url.searchParams.get('category'));
const technologyFilter = safeDecode(Astro.url.searchParams.get('technology'));
const industriesFilter = safeDecode(Astro.url.searchParams.get('industries'));
const page = Math.max(1, parseInt(Astro.url.searchParams.get('page') || '1', 10));
const pageSize = 24;

// Fetch all categories from database for the dropdown (cached)
const categoriesCacheKey = 'categories:all';
let dbCategories: Category[] | null = getCached<Category[]>(categoriesCacheKey);
if (!dbCategories) {
  const { data } = await supabase
    .from('categories')
    .select('id, slug, name_en, name_de')
    .order('name_en', { ascending: true });
  dbCategories = data as Category[] | null;
  if (dbCategories) {
    setCached(categoriesCacheKey, dbCategories, 300);
  }
}

// Get category ID if category filter is active
let categoryId: string | null = null;
if (activeCategory) {
  const category = dbCategories?.find(cat => cat.slug === activeCategory);
  categoryId = category?.id || null;
}

// Fetch unique countries from all vendors for dropdown (cached)
const countriesCacheKey = 'vendors:countries:all';
let uniqueCountryList = getCached<string[]>(countriesCacheKey);
if (!uniqueCountryList) {
  const { data: allVendorsForCountries } = await supabase
    .from('vendors')
    .select('country')
    .not('country', 'is', null)
    .neq('plan', 'deactivated');
  
  uniqueCountryList = Array.from(
    new Set((allVendorsForCountries || []).map(v => v.country).filter(Boolean))
  ).sort();
  
  if (uniqueCountryList) {
    setCached(countriesCacheKey, uniqueCountryList, 300);
  }
}
// Ensure uniqueCountryList is always an array (never null)
if (!uniqueCountryList) {
  uniqueCountryList = [];
}

// Fetch all vendors to extract unique technologies for dropdown (cached)
const technologiesCacheKey = 'vendors:technologies:all';
let uniqueTechnologyList = getCached<string[]>(technologiesCacheKey);
if (!uniqueTechnologyList) {
  // Fetch technologies from vendor_technologies join
  // First get all active vendor IDs
  const { data: activeVendors } = await supabase
    .from('vendors')
    .select('id')
    .neq('plan', 'deactivated');
  
  const activeVendorIds = (activeVendors || []).map(v => v.id);
  
  if (activeVendorIds.length > 0) {
    const { data: vendorTechnologies } = await supabase
      .from('vendor_technologies')
      .select(`
        technologies:technologies (
          name_en,
          name_de
        )
      `)
      .in('vendor_id', activeVendorIds);
    
    // Extract and normalize unique technologies
    const technologySet = new Set<string>();
    (vendorTechnologies || []).forEach((vt: any) => {
      if (vt.technologies) {
        const techNameEn = vt.technologies.name_en;
        const techNameDe = vt.technologies.name_de;
        if (techNameEn) technologySet.add(techNameEn);
        if (techNameDe) technologySet.add(techNameDe);
      }
    });
    
    uniqueTechnologyList = Array.from(technologySet).sort();
  } else {
    uniqueTechnologyList = [];
  }
  
  if (uniqueTechnologyList) {
    setCached(technologiesCacheKey, uniqueTechnologyList, 300);
  }
}
// Ensure uniqueTechnologyList is always an array (never null)
if (!uniqueTechnologyList) {
  uniqueTechnologyList = [];
}

// Fetch active industries for dropdown (cached)
const industriesCacheKey = `industries:active:${lang}`;
let industryList = getCached<any[]>(industriesCacheKey);
if (!industryList) {
  industryList = await getIndustries({ lang, activeOnly: true });
  if (industryList) {
    setCached(industriesCacheKey, industryList, 300);
  }
}
if (!industryList) {
  industryList = [];
}

// Helper function to convert country name to URL-friendly slug
function countryToSlug(country: string): string {
  return country
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/[^\w\-]/g, ''); // Remove special characters except hyphens
}

// Helper function to convert country slug back to country name
function slugToCountryName(slug: string): string | null {
  // Find the country in uniqueCountryList that matches this slug
  if (!uniqueCountryList) return null;
  const matchingCountry = uniqueCountryList.find(country => 
    countryToSlug(country) === slug
  );
  return matchingCountry || null;
}

// Helper function to convert technology slug back to technology name
function slugToTechnologyName(slug: string): string | null {
  // Find the technology in uniqueTechnologyList that matches this slug
  if (!uniqueTechnologyList) return null;
  const matchingTechnology = uniqueTechnologyList.find(tech => 
    normalizeTech(tech) === slug
  );
  return matchingTechnology || null;
}

// Normalize technology filter: convert slug to actual technology name
let normalizedTechnologyFilter: string | null = null;
if (technologyFilter) {
  const technologyName = slugToTechnologyName(technologyFilter);
  if (technologyName) {
    normalizedTechnologyFilter = technologyName;
  }
}

// Normalize country filter: convert slug to actual country name
let normalizedCountryFilter: string | null = null;
if (countryFilter) {
  const countryName = slugToCountryName(countryFilter);
  if (countryName) {
    normalizedCountryFilter = countryName;
  }
}

// If category filter is active, first get vendor IDs that have this category (cached)
let categoryVendorIds: string[] | null = null;
if (categoryId) {
  const categoryLinksCacheKey = `vendor_categories:category:${categoryId}`;
  categoryVendorIds = getCached<string[]>(categoryLinksCacheKey);
  
  if (categoryVendorIds === null) {
    const { data: vendorCategoryLinks, error: linkError } = await supabase
      .from('vendor_categories')
      .select('vendor_id')
      .eq('category_id', categoryId);

    if (linkError) {
      console.error('Error fetching vendor-category links:', linkError);
      categoryVendorIds = [];
    } else {
      categoryVendorIds = (vendorCategoryLinks || []).map(link => link.vendor_id);
      // If no vendors found for this category, set empty array to return no results
      if (categoryVendorIds.length === 0) {
        categoryVendorIds = [];
      }
      setCached(categoryLinksCacheKey, categoryVendorIds, 300);
    }
  }
}

// If technology filter is active, first get vendor IDs that have this technology (cached)
let techVendorIds: string[] | null = null;
if (normalizedTechnologyFilter) {
  const techLinksCacheKey = `vendor_technologies:filter:${normalizedTechnologyFilter.toLowerCase()}`;
  techVendorIds = getCached<string[]>(techLinksCacheKey);
  
  if (techVendorIds === null) {
    const { data: techVendorLinks } = await supabase
      .from('vendor_technologies')
      .select(`
        vendor_id,
        technologies:technologies (
          name_en,
          name_de
        )
      `);
    
    techVendorIds = [];
    if (techVendorLinks) {
      const filterLower = normalizedTechnologyFilter.toLowerCase();
      techVendorLinks.forEach((link: any) => {
        const techNameEn = link.technologies?.name_en?.toLowerCase() || '';
        const techNameDe = link.technologies?.name_de?.toLowerCase() || '';
        if (techNameEn.includes(filterLower) || techNameDe.includes(filterLower)) {
          techVendorIds!.push(link.vendor_id);
        }
      });
    }
    setCached(techLinksCacheKey, techVendorIds, 300);
  }
}

// Parse industries filter (support comma-separated slugs)
let industrySlugs: string[] = [];
if (industriesFilter) {
  industrySlugs = industriesFilter.split(',').map(s => s.trim()).filter(Boolean);
}

// If industry filter is active, get vendor IDs that have these industries (cached)
let industryVendorIds: string[] | null = null;
if (industrySlugs.length > 0) {
  const industryLinksCacheKey = `vendor_industries:filter:${industrySlugs.sort().join(',')}`;
  industryVendorIds = getCached<string[]>(industryLinksCacheKey);
  
  if (industryVendorIds === null) {
    // Get industry IDs from slugs
    const industryIds: string[] = [];
    for (const slug of industrySlugs) {
      const industry = industryList.find(ind => ind.slug === slug);
      if (industry?.id) {
        industryIds.push(industry.id);
      }
    }
    
    if (industryIds.length > 0) {
      const { data: vendorIndustryLinks, error: linkError } = await supabase
        .from('vendor_industries')
        .select('vendor_id')
        .in('industry_id', industryIds);
      
      if (linkError) {
        console.error('Error fetching vendor-industry links:', linkError);
        industryVendorIds = [];
      } else {
        // Get unique vendor IDs
        industryVendorIds = Array.from(new Set((vendorIndustryLinks || []).map(link => link.vendor_id)));
        if (industryVendorIds.length === 0) {
          industryVendorIds = [];
        }
      }
    } else {
      industryVendorIds = [];
    }
    
    setCached(industryLinksCacheKey, industryVendorIds, 300);
  }
}

// Helper function to build count query with filters
function buildCountQuery() {
  let query = supabase
    .from('vendors')
    .select('*', { count: 'exact', head: true })
    .neq('plan', 'deactivated');

  // Apply category filter using vendor IDs if present
  if (categoryVendorIds !== null) {
    if (categoryVendorIds.length === 0) {
      // No vendors match this category, return empty result by filtering to non-existent UUID
      query = query.eq('id', '00000000-0000-0000-0000-000000000000');
    } else {
      query = query.in('id', categoryVendorIds);
    }
  }

  // Apply search filter if present (filter by vendor name)
  if (searchQuery) {
    query = query.ilike('name', `%${searchQuery}%`);
  }

  // Apply country filter if present (use case-insensitive matching)
  if (normalizedCountryFilter) {
    query = query.ilike('country', normalizedCountryFilter);
  }

  // Apply technology filter if present (filter via vendor_technologies join)
  if (techVendorIds !== null) {
    if (techVendorIds.length === 0) {
      // No vendors match this technology, return empty result
      query = query.eq('id', '00000000-0000-0000-0000-000000000000');
    } else {
      query = query.in('id', techVendorIds);
    }
  }

  // Apply industry filter if present (filter via vendor_industries join)
  if (industryVendorIds !== null) {
    if (industryVendorIds.length === 0) {
      // No vendors match these industries, return empty result
      query = query.eq('id', '00000000-0000-0000-0000-000000000000');
    } else {
      query = query.in('id', industryVendorIds);
    }
  }

  return query;
}

// Helper function to build base query with filters
function buildBaseQuery() {
  let query = supabase
    .from('vendors')
    .select(`
      *,
      vendor_categories (
        is_primary,
        categories:categories (
          id,
          slug,
          name_en,
          name_de
        )
      )
    `, { count: 'exact' })
    .neq('plan', 'deactivated');

  // Apply category filter using vendor IDs if present
  if (categoryVendorIds !== null) {
    if (categoryVendorIds.length === 0) {
      // No vendors match this category, return empty result by filtering to non-existent UUID
      query = query.eq('id', '00000000-0000-0000-0000-000000000000');
    } else {
      query = query.in('id', categoryVendorIds);
    }
  }

  // Apply search filter if present (filter by vendor name)
  if (searchQuery) {
    query = query.ilike('name', `%${searchQuery}%`);
  }

  // Apply country filter if present (use case-insensitive matching)
  if (normalizedCountryFilter) {
    query = query.ilike('country', normalizedCountryFilter);
  }

  // Apply technology filter if present (filter via vendor_technologies join)
  if (techVendorIds !== null) {
    if (techVendorIds.length === 0) {
      // No vendors match this technology, return empty result
      query = query.eq('id', '00000000-0000-0000-0000-000000000000');
    } else {
      query = query.in('id', techVendorIds);
    }
  }

  // Apply industry filter if present (filter via vendor_industries join)
  if (industryVendorIds !== null) {
    if (industryVendorIds.length === 0) {
      // No vendors match these industries, return empty result
      query = query.eq('id', '00000000-0000-0000-0000-000000000000');
    } else {
      query = query.in('id', industryVendorIds);
    }
  }

  // Sort by priority (high priority first, nulls last), then by name ascending
  query = query.order('priority', { ascending: false, nullsFirst: false })
    .order('name', { ascending: true });

  return query;
}

// Build cache key for vendor listing query
const cacheKey = `vendors:list:${lang}:${searchQuery || ''}:${activeCategory || ''}:${countryFilter || ''}:${technologyFilter || ''}:${industriesFilter || ''}:${page}`;

// Try to get cached result
interface CachedVendorResult {
  vendors: any[];
  totalVendors: number | null;
}

let cachedResult = getCached<CachedVendorResult>(cacheKey);
let vendors: any[] = [];
let totalVendors: number | null = null;

if (cachedResult) {
  vendors = cachedResult.vendors || [];
  totalVendors = cachedResult.totalVendors;
} else {
  // Get total count
  const countQuery = buildCountQuery();
  const { count } = await countQuery;
  totalVendors = count;

  // Build paginated query
  let paginatedQuery = buildBaseQuery();
  const start = (page - 1) * pageSize;
  const end = page * pageSize - 1;
  paginatedQuery = paginatedQuery.range(start, end);

  // Execute paginated query
  const { data, error } = await paginatedQuery;

  if (error) {
    console.error('Error fetching vendors:', error);
    vendors = [];
  } else {
    vendors = data || [];
  }

  // Cache the result
  if (totalVendors !== null) {
    setCached(cacheKey, { vendors, totalVendors }, 300);
  }
}

// Normalize category data shape
const normalizedVendors = normalizeVendors(vendors || []);

const filteredVendors = normalizedVendors;
const totalPages = Math.ceil((totalVendors || 0) / pageSize);

// Build category list with slugs from database categories
const categoryList = (dbCategories || []).map(cat => ({
  slug: cat.slug,
  name: lang === "de" ? (cat.name_de || cat.name_en) : (cat.name_en || cat.name_de)
})).filter(cat => cat.slug && cat.name);

---

<div class="container-px mx-auto max-w-7xl px-4 py-10">
  <h1 class="text-3xl font-bold text-gray-900 mb-8">{pageTitle}</h1>
  {description && (
    <p class="text-lg md:text-xl text-gray-600 mb-8 max-w-3xl">{description}</p>
  )}

  <!-- Category Filter Badges -->
  {categoryList.length > 0 && (
    <div class="mb-6 flex flex-wrap gap-2">
      {categoryList.map(cat => {
        // Build URL preserving existing query params but updating category
        const url = new URL(Astro.url);
        if (cat.slug === activeCategory) {
          // If clicking active category, remove it (clear filter)
          url.searchParams.delete('category');
        } else {
          // Set new category
          url.searchParams.set('category', cat.slug);
        }
        // Preserve other filters (search, country, technology, industries)
        if (searchQuery) url.searchParams.set('q', searchQuery);
        if (countryFilter) url.searchParams.set('country', countryFilter);
        if (technologyFilter) url.searchParams.set('technology', technologyFilter);
        if (industriesFilter) url.searchParams.set('industries', industriesFilter);
        // Reset to page 1 when filter changes
        url.searchParams.set('page', '1');
        return (
          <a
            href={url.toString()}
            class={`px-3 py-1 rounded-md text-sm cursor-pointer ${
              cat.slug === activeCategory ? "bg-black text-white" : "bg-gray-100 text-gray-700"
            }`}
          >
            {cat.name}
          </a>
        );
      })}
    </div>
  )}

  <!-- Search and Filter Form -->
  <div class="border border-gray-200 rounded-lg p-4 mb-8 bg-white shadow-sm">
    <form method="GET" action={Astro.url.pathname}>
      <!-- Reset to page 1 when filters change -->
      <input type="hidden" name="page" value="1" />
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
        <!-- Search Bar -->
        <div>
          <input
            type="text"
            name="q"
            value={searchQuery}
            placeholder={lang === "de" ? "Suchen..." : "Search..."}
            class="border border-gray-300 rounded-md px-3 py-2 w-full text-sm"
          />
        </div>

        <!-- Country Filter -->
        <div>
          <select
            name="country"
            class="border border-gray-300 rounded-md px-3 py-2 w-full text-sm"
          >
            <option value="">{lang === "de" ? "Alle Länder" : "All Countries"}</option>
            {uniqueCountryList.map(country => {
              const countrySlug = countryToSlug(country);
              return (
                <option value={countrySlug} selected={countryFilter === countrySlug}>
                  {country}
                </option>
              );
            })}
          </select>
        </div>

        <!-- Category Filter -->
        <div>
          <select
            name="category"
            class="border border-gray-300 rounded-md px-3 py-2 w-full text-sm"
          >
            <option value="">{lang === "de" ? "Alle Kategorien" : "All Categories"}</option>
            {categoryList.map(cat => (
              <option value={cat.slug} selected={activeCategory === cat.slug}>
                {cat.name}
              </option>
            ))}
          </select>
        </div>

        <!-- Technology Filter -->
        <div>
          <select
            name="technology"
            class="border border-gray-300 rounded-md px-3 py-2 w-full text-sm"
          >
            <option value="">{lang === "de" ? "Alle Technologien" : "All Technologies"}</option>
            {uniqueTechnologyList.map(tech => {
              const techSlug = normalizeTech(tech);
              return (
                <option value={techSlug} selected={technologyFilter === techSlug}>
                  {tech}
                </option>
              );
            })}
          </select>
        </div>

        <!-- Industry Filter -->
        <div>
          <select
            name="industries"
            class="border border-gray-300 rounded-md px-3 py-2 w-full text-sm"
          >
            <option value="">{lang === "de" ? "Alle Branchen" : "All Industries"}</option>
            {industryList.map(industry => {
              // For single select, use first slug if multiple are selected
              const selectedSlug = industrySlugs.length > 0 ? industrySlugs[0] : '';
              return (
                <option value={industry.slug} selected={selectedSlug === industry.slug}>
                  {industry.name}
                </option>
              );
            })}
          </select>
        </div>
      </div>

      <!-- Filter Buttons -->
      <div class="mt-4 flex gap-3">
        <button
          type="submit"
          class="bg-brand-600 text-white px-4 py-2 rounded-md hover:bg-brand-700 text-sm font-medium"
        >
          {lang === "de" ? "Filtern" : "Filter"}
        </button>
        {(searchQuery || countryFilter || activeCategory || technologyFilter || industriesFilter) && (
          <a
            href={Astro.url.pathname}
            class="px-4 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 text-sm font-medium"
          >
            {lang === "de" ? "Zurücksetzen" : "Clear"}
          </a>
        )}
      </div>
    </form>
  </div>

  <!-- Result Count -->
  <div class="mb-4">
    <p class="text-sm text-gray-600">
      {totalVendors || 0} {lang === "de" ? "Anbieter gefunden" : "vendors found"}
      {(searchQuery || countryFilter || activeCategory || technologyFilter || industriesFilter) && (
        <span class="text-xs text-gray-500 ml-2">
          ({lang === "de" ? "gefiltert" : "filtered"})
        </span>
      )}
      {totalPages > 1 && (
        <span class="text-xs text-gray-500 ml-2">
          ({lang === "de" ? "Seite" : "Page"} {page} {lang === "de" ? "von" : "of"} {totalPages})
        </span>
      )}
    </p>
    {(searchQuery || countryFilter || activeCategory || technologyFilter || industriesFilter) && (
      <div class="mt-2 flex flex-wrap gap-2">
        {searchQuery && (
          <span class="inline-flex items-center px-2 py-1 rounded text-xs bg-blue-100 text-blue-800">
            {lang === "de" ? "Suche" : "Search"}: "{searchQuery}"
          </span>
        )}
        {countryFilter && normalizedCountryFilter && (
          <span class="inline-flex items-center px-2 py-1 rounded text-xs bg-green-100 text-green-800">
            {lang === "de" ? "Land" : "Country"}: {normalizedCountryFilter}
          </span>
        )}
        {activeCategory && (
          <span class="inline-flex items-center px-2 py-1 rounded text-xs bg-purple-100 text-purple-800">
            {lang === "de" ? "Kategorie" : "Category"}: {activeCategory}
          </span>
        )}
        {technologyFilter && normalizedTechnologyFilter && (
          <span class="inline-flex items-center px-2 py-1 rounded text-xs bg-orange-100 text-orange-800">
            {lang === "de" ? "Technologie" : "Technology"}: {normalizedTechnologyFilter}
          </span>
        )}
        {industriesFilter && industrySlugs.length > 0 && (
          <span class="inline-flex items-center px-2 py-1 rounded text-xs bg-indigo-100 text-indigo-800">
            {lang === "de" ? "Branche" : "Industry"}: {industryList.find(ind => ind.slug === industrySlugs[0])?.name || industrySlugs[0]}
            {industrySlugs.length > 1 && ` +${industrySlugs.length - 1}`}
          </span>
        )}
      </div>
    )}
  </div>

  <!-- Vendor Grid -->
  <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
    {filteredVendors.length > 0 ? (
      filteredVendors.map(vendor => (
        <VendorCard
          vendor={vendor}
          hrefPrefix={`/${lang}/vendor`}
          lang={lang}
        />
      ))
    ) : (
      <div class="col-span-full text-center py-12">
        <p class="text-gray-600">
          {lang === "de" ? "Keine Anbieter gefunden." : "No vendors found."}
        </p>
      </div>
    )}
  </div>

  <!-- Pagination -->
  <Pagination
    currentPage={page}
    totalPages={totalPages}
    baseUrl={Astro.url}
    lang={lang}
  />
</div>

