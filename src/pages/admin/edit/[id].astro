---
export const prerender = false;

import { supabaseAdmin } from '../../../lib/supabaseAdminClient';
import { createSupabaseServerClient } from '../../../lib/supabaseServer';
import { protectAdminRoute } from '../../../lib/admin/authUtils';
import AdminLayout from '../../../components/admin/AdminLayout.astro';
import VendorForm from '../../../components/admin/VendorForm.astro';

// Handle logout first (before auth check)
if (Astro.url.searchParams.get('logout') === 'true') {
  return Astro.redirect('/api/admin/logout');
}

// Check authentication and redirect if not logged in
// Note: Middleware also handles this, but keeping as defensive check
const redirectResponse = await protectAdminRoute(Astro.locals);
if (redirectResponse) {
  return redirectResponse;
}

const { id } = Astro.params;

// Create Supabase server client for authenticated operations
const supabase = createSupabaseServerClient(Astro.cookies);

// Fetch all categories from Supabase (using admin client for consistency)
const { data: categories } = await supabaseAdmin
  .from('categories')
  .select('id, slug, name_en, name_de')
  .order('order_index', { ascending: true })
  .order('name_en', { ascending: true });

// Handle form submission
if (Astro.request.method === 'POST') {
  // Verify authentication
  const { data: { user } } = await supabase.auth.getUser();
  
  if (!user) {
    return Astro.redirect('/admin/login');
  }

  // Verify admin role
  const { data: roleData } = await supabase
    .from('user_roles')
    .select('role')
    .eq('user_id', user.id)
    .limit(1)
    .maybeSingle();

  if (roleData?.role !== 'admin') {
    return Astro.redirect('/admin/login');
  }

  const formData = await Astro.request.formData();
  
  // Extract vendor ID
  const vendorId = formData.get('id')?.toString() || '';
  
  if (!vendorId) {
    console.error('Error: Vendor ID is required');
    return Astro.redirect(`/admin/edit/${id}?error=missing_id`);
  }

  // Extract category slugs from form data
  const categorySlugs = formData.getAll("category_slugs")
    .map((slug) => String(slug).trim())
    .filter((slug) => slug.length > 0);
  
  // Extract technology slugs from form data
  const technologySlugs = formData.getAll("technology_slugs")
    .map((slug) => String(slug).trim())
    .filter((slug) => slug.length > 0);
  
  // Extract industry slugs from form data
  const industrySlugs = formData.getAll("industry_slugs")
    .map((slug) => String(slug).trim())
    .filter((slug) => slug.length > 0);
  
  // Build updateData from form fields
  const updateData: any = {
    name: formData.get('name')?.toString() || null,
    slug: formData.get('slug')?.toString() || null,
    description_en: formData.get('description_en')?.toString() || null,
    description_de: formData.get('description_de')?.toString() || null,
    website: formData.get('website')?.toString() || null,
    email: formData.get('email')?.toString() || null,
    phone: formData.get('phone')?.toString() || null,
    address: formData.get('address')?.toString() || null,
    city: formData.get('city')?.toString() || null,
    region: formData.get('region')?.toString() || null,
    country: formData.get('country')?.toString() || null,
    languages: formData.get('languages')?.toString() || null,
    certifications: formData.get('certifications')?.toString() || null,
    tags: formData.get('tags')?.toString() || null,
    year_founded: formData.get('year_founded')?.toString() || null,
    employee_count: formData.get('employee_count')?.toString() || null,
    hourly_rate: formData.get('hourly_rate')?.toString() || null,
    plan: formData.get('plan')?.toString() || 'free',
    priority: formData.get('priority')?.toString() ? parseInt(formData.get('priority')!.toString()) : null,
    featured: formData.get('featured') === 'on',
    og_member: formData.get('og_member') === 'on',
    featured_until: formData.get('featured_until')?.toString() || null,
    meta_title: formData.get('meta_title')?.toString() || null,
    meta_description: formData.get('meta_description')?.toString() || null,
    canonical_url: formData.get('canonical_url')?.toString() || null,
    logo_url: formData.get('logo_url')?.toString() || null,
    logo_width: formData.get('logo_width')?.toString() ? Number(formData.get('logo_width')!.toString()) : null,
    logo_height: formData.get('logo_height')?.toString() ? Number(formData.get('logo_height')!.toString()) : null,
    logo_format: formData.get('logo_format')?.toString() || null,
    logo_alt: formData.get('logo_alt')?.toString() || null,
  };

  // Normalize website URL: add https:// if missing
  if (updateData.website && typeof updateData.website === 'string') {
    const website = updateData.website.trim();
    if (website && !website.match(/^https?:\/\//i)) {
      updateData.website = 'https://' + website;
    }
  }

  // Add updated_at timestamp
  updateData.updated_at = new Date().toISOString();

  // Update vendor using admin client
  const { error: updateError } = await supabaseAdmin
    .from('vendors')
    .update(updateData)
    .eq('id', vendorId);

  if (updateError) {
    console.error('Error updating vendor:', updateError);
    return Astro.redirect(`/admin/edit/${vendorId}?error=update_failed`);
  }

  // Update vendor_categories: delete all existing entries and reinsert new ones
  await supabaseAdmin
    .from('vendor_categories')
    .delete()
    .eq('vendor_id', vendorId);

  // Insert new vendor_categories entries if category slugs were provided
  if (categorySlugs.length > 0) {
    for (const slug of categorySlugs) {
      const { data: cat } = await supabaseAdmin
        .from("categories")
        .select("id")
        .eq("slug", slug)
        .single();

      if (cat?.id) {
        await supabaseAdmin
          .from("vendor_categories")
          .insert({
            vendor_id: vendorId,
            category_id: cat.id
          });
      }
    }
  }

  // Update vendor_technologies: delete all existing entries and reinsert new ones
  await supabaseAdmin
    .from('vendor_technologies')
    .delete()
    .eq('vendor_id', vendorId);

  // Insert new vendor_technologies entries if technology slugs were provided
  if (technologySlugs.length > 0) {
    for (const slug of technologySlugs) {
      const { data: tech } = await supabaseAdmin
        .from("technologies")
        .select("id")
        .eq("slug", slug)
        .single();

      if (tech?.id) {
        await supabaseAdmin
          .from("vendor_technologies")
          .insert({
            vendor_id: vendorId,
            technology_id: tech.id
          });
      }
    }
  }

  // Update vendor_industries: delete all existing entries and reinsert new ones
  await supabaseAdmin
    .from('vendor_industries')
    .delete()
    .eq('vendor_id', vendorId);

  // Insert new vendor_industries entries if industry slugs were provided
  if (industrySlugs.length > 0) {
    for (const slug of industrySlugs) {
      const { data: industry } = await supabaseAdmin
        .from("industries")
        .select("id")
        .eq("slug", slug)
        .single();

      if (industry?.id) {
        await supabaseAdmin
          .from("vendor_industries")
          .insert({
            vendor_id: vendorId,
            industry_id: industry.id
          });
      }
    }
  }

  // Redirect back to admin panel after successful update
  return Astro.redirect('/admin');
}

// Fetch vendor by ID with vendor_categories, vendor_technologies, and vendor_industries
const { data: vendor, error } = await supabaseAdmin
  .from('vendors')
  .select(`
    *,
    vendor_categories (
      categories:categories (
        id,
        slug,
        name_en,
        name_de
      )
    ),
    vendor_technologies (
      technologies:technologies (
        id,
        slug,
        name_en,
        name_de
      )
    ),
    vendor_industries (
      industries:industries (
        id,
        slug,
        name_en,
        name_de
      )
    )
  `)
  .eq('id', id)
  .maybeSingle();

if (error) {
  console.error('Error fetching vendor:', error);
}

if (!vendor) {
  return Astro.redirect('/admin');
}

// Fetch all technologies from Supabase
const { data: technologies } = await supabaseAdmin
  .from('technologies')
  .select('id, slug, name_en, name_de')
  .eq('is_active', true)
  .order('order_index', { ascending: true, nullsFirst: false })
  .order('name_en', { ascending: true });

// Fetch all industries from Supabase (active only)
const { data: industries } = await supabaseAdmin
  .from('industries')
  .select('id, slug, name_en, name_de')
  .eq('is_active', true)
  .order('order_index', { ascending: true, nullsFirst: false })
  .order('name_en', { ascending: true });

// Normalize category data shape - extract category_slugs from vendor_categories M2M
// Normalize technology data shape - extract technology_slugs from vendor_technologies M2M
// Normalize industry data shape - extract industry_slugs from vendor_industries M2M
const normalizedVendor = {
  ...vendor,
  category_slugs: vendor.vendor_categories?.map((vc: any) => vc.categories?.slug).filter(Boolean) || [],
  technology_slugs: vendor.vendor_technologies?.map((vt: any) => vt.technologies?.slug).filter(Boolean) || [],
  industry_slugs: vendor.vendor_industries?.map((vi: any) => vi.industries?.slug).filter(Boolean) || []
};

---

<AdminLayout title={`Edit Vendor: ${normalizedVendor.name} - Admin Panel`} currentPath="/admin">
  <div class="space-y-6">
    <!-- HEADER -->
    <div class="flex items-center justify-between">
      <div>
        <h1 class="text-2xl font-bold text-gray-900">Edit Vendor</h1>
        <p class="mt-1 text-sm text-gray-600">
          {normalizedVendor.name || 'Vendor'}
        </p>
      </div>
      <a
        href="/admin"
        class="text-sm text-gray-600 hover:text-gray-900"
      >
        ‚Üê Back to Vendor List
      </a>
    </div>

    <!-- VENDOR FORM -->
    <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
      <VendorForm vendor={normalizedVendor} categories={categories || []} technologies={technologies || []} industries={industries || []} />
    </div>
  </div>
</AdminLayout>

