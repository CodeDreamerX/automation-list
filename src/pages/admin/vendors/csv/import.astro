---
export const prerender = false;

import { protectAdminRoute } from '../../../../lib/admin/authUtils';
import { supabase } from '../../../../lib/supabaseClient';
import { supabaseAdmin } from '../../../../lib/supabaseAdminClient';
import { normalizeRow, validateRow } from '../../../../lib/admin/csvUtils';
import { readFile, unlink } from 'fs/promises';
import { join } from 'path';
import Papa from 'papaparse';

// Check authentication and redirect if not logged in
const redirectResponse = await protectAdminRoute(Astro.locals);
if (redirectResponse) {
  return redirectResponse;
}

// Handle POST request
if (Astro.request.method === 'POST') {
  const formData = await Astro.request.formData();
  const sessionId = formData.get('sessionId')?.toString();

  if (!sessionId) {
    return Astro.redirect('/admin/vendors/csv/upload?error=no_session');
  }

  // Read the uploaded CSV file
  let fileContent: string;
  const tempFilePath = join(process.cwd(), '.temp', 'csv-uploads', `${sessionId}.csv`);
  
  try {
    fileContent = await readFile(tempFilePath, 'utf-8');
  } catch (error) {
    console.error('Error reading uploaded file:', error);
    return Astro.redirect('/admin/vendors/csv/upload?error=file_not_found');
  }

  // Parse CSV
  let parsedData: any[];
  try {
    const parseResult = Papa.parse(fileContent, {
      header: true,
      skipEmptyLines: true,
      transformHeader: (header: string) => header.trim(),
    });
    parsedData = parseResult.data;
  } catch (error) {
    console.error('Error parsing CSV:', error);
    return Astro.redirect('/admin/vendors/csv/upload?error=parse_error');
  }

  if (!parsedData || parsedData.length === 0) {
    return Astro.redirect('/admin/vendors/csv/upload?error=empty_csv');
  }

  // Normalize and process rows
  const normalizedData: any[] = [];
  const allSlugs: string[] = [];

  for (const row of parsedData) {
    const { normalized } = normalizeRow(row);
    
    // _categorySlugs and _technologySlugs are already generated by normalizeRow from category_slugs and technology_slugs fields
    
    normalizedData.push(normalized);
    if (normalized.slug) {
      allSlugs.push(normalized.slug);
    }
  }

  // Track import results
  const results = {
    success: 0,
    skipped: 0,
    errors: 0,
    warnings: [] as string[],
    errorsList: [] as string[],
  };

  // Process each row
  for (let i = 0; i < normalizedData.length; i++) {
    const row = normalizedData[i];
    const rowNum = i + 2; // +2 because CSV has header row and arrays are 0-indexed

    try {
      // Validate required fields
      const validation = validateRow(row, i, allSlugs);
      if (validation.missingRequired.length > 0) {
        results.skipped++;
        results.errorsList.push(`Row ${rowNum} (${row.name || 'unnamed'}): Missing required fields: ${validation.missingRequired.join(', ')}`);
        continue;
      }

      // Check if slug already exists
      const { data: existingVendor } = await supabase
        .from('vendors')
        .select('id')
        .eq('slug', row.slug)
        .maybeSingle();

      if (existingVendor) {
        results.skipped++;
        results.warnings.push(`Row ${rowNum} (${row.name || 'unnamed'}): Slug "${row.slug}" already exists, skipped`);
        continue;
      }

      // Prepare vendor data with explicit field mapping and type conversions
      const vendorData = {
        name: row.name,
        slug: row.slug,
        country: row.country,
        region: row.region || null,
        city: row.city || null,
        address: row.address || null,
        website: row.website || null,
        email: row.email || null,
        phone: row.phone || null,
        description: row.description || null,
        technologies: row.technologies || null,
        languages: row.languages || null,
        certifications: row.certifications || null,
        tags: row.tags || null,
        industries: row.industries || null,
        year_founded: row.year_founded || null,
        employee_count: row.employee_count || null,
        hourly_rate: row.hourly_rate || null,
        plan: row.plan || "free",
        featured: !!row.featured,
        priority: Number(row.priority) || 5,
        og_member: !!row.og_member,
      };

      // Normalize website URL
      if (vendorData.website && typeof vendorData.website === 'string') {
        const website = vendorData.website.trim();
        if (website && !website.match(/^https?:\/\//i)) {
          vendorData.website = 'https://' + website;
        }
      }

      // Add timestamps
      vendorData.created_at = new Date().toISOString();
      vendorData.updated_at = new Date().toISOString();

      // Insert vendor using admin client and retrieve new vendor ID
      const { data: vendor, error: vendorError } = await supabaseAdmin
        .from('vendors')
        .insert([vendorData])
        .select('id')
        .single();

      if (vendorError || !vendor) {
        results.errors++;
        results.errorsList.push(`Row ${rowNum} (${row.name || 'unnamed'}): ${vendorError?.message || 'Failed to create vendor'}`);
        continue;
      }

      const vendorId = vendor.id;

      // Insert vendor_categories for each category slug
      for (const slug of row._categorySlugs) {
        const { data: category } = await supabaseAdmin
          .from("categories")
          .select("id")
          .eq("slug", slug)
          .single();

        if (category) {
          const { error: vendorCategoryError } = await supabaseAdmin
            .from("vendor_categories")
            .insert({
              vendor_id: vendorId,
              category_id: category.id,
              is_primary: false,
            });

          if (vendorCategoryError) {
            results.warnings.push(`Row ${rowNum} (${row.name || 'unnamed'}): Failed to link category "${slug}": ${vendorCategoryError.message}`);
          }
        } else {
          // Add warning for unknown category slug
          results.warnings.push(`Row ${rowNum} (${row.name || 'unnamed'}): Unknown category slug: ${slug}`);
        }
      }

      // Insert vendor_technologies for each technology slug
      if (row._technologySlugs && Array.isArray(row._technologySlugs)) {
        for (const slug of row._technologySlugs) {
          const { data: technology } = await supabaseAdmin
            .from("technologies")
            .select("id")
            .eq("slug", slug)
            .single();

          if (technology) {
            const { error: vendorTechnologyError } = await supabaseAdmin
              .from("vendor_technologies")
              .insert({
                vendor_id: vendorId,
                technology_id: technology.id,
              });

            if (vendorTechnologyError) {
              results.warnings.push(`Row ${rowNum} (${row.name || 'unnamed'}): Failed to link technology "${slug}": ${vendorTechnologyError.message}`);
            }
          } else {
            // Add warning for unknown technology slug
            results.warnings.push(`Row ${rowNum} (${row.name || 'unnamed'}): Unknown technology slug: ${slug}`);
          }
        }
      }

      results.success++;

    } catch (error: any) {
      results.errors++;
      results.errorsList.push(`Row ${rowNum} (${row.name || 'unnamed'}): ${error.message || 'Unexpected error'}`);
    }
  }

  // Clean up temporary file
  try {
    await unlink(tempFilePath);
  } catch (error) {
    console.error('Error deleting temp file:', error);
  }

  // Clear session cookies
  Astro.cookies.delete('csv_upload_session', { path: '/' });
  Astro.cookies.delete('csv_upload_filename', { path: '/' });

  // Return JSON summary
  return new Response(
    JSON.stringify({
      imported: results.success,
      failed: results.errors,
      warnings: results.warnings,
      errors: results.errorsList,
      skipped: results.skipped,
    }),
    {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    }
  );
}

// If not POST, redirect to upload
return Astro.redirect('/admin/vendors/csv/upload');
---

